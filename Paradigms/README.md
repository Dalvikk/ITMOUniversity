# Парадигмы программирования

Домашние работы курса 2-ого семестра «Парадигмы программирования» кафедры КТ, университета ИТМО

## Домашнее задание 6. Объектные выражения на JavaScript

[Решение](./src/JSfunctionalExpression/objectExpression.js)  
[Исходный код тестов](./tests/src/javascript/jstest/object/ObjectHarmonicTest.java)

1.  Разработайте классы`Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate`, для представления выражений с одной переменной.

  1.  Пример описания выражения `2x-3`
```javascript
let expr = new Subtract(
            new Multiply(
            new Const(2),
                new Variable("x")
        ),
            new Const(3)
);
    console.log(expr.evaluate(5));      
```
  2.  При вычислении такого выражения вместо каждой переменной подставляется её значение, переданное в качестве аргумента метода `evaluate`. Таким образом, результатом вычисления приведенного примера должно стать число 7.
  3.  Метод `toString()` должен выдавать запись выражения в [обратной польской записи](https://ru.wikipedia.org/wiki/Обратная_польская_запись). Например, `expr.toString()` должен выдавать «`2 x * 3 -`».
    
2.  Сложный вариант.

    Метод `diff("x")` должен возвращать выражение, представляющее производную исходного выражения по переменной `x`. Например, `expr.diff("x")` должен возвращать выражение, эквивалентное `new Const(2)` (выражения `new Subtract(new Const(2), new Const(0))` и

    ```javascript
    new Subtract(
        new Add(
            new Multiply(new Const(0), new Variable("x")),
            new Multiply(new Const(2), new Const(1))
        )
        new Const(0)
    )            
    ```
    

так же будут считаться правильным ответом).

Функция `parse` должна выдавать разобранное объектное выражение.   

3.  Бонусный вариант.

    Требуется написать метод `simplify()`, производящий вычисления константных выражений. Например,

```javascript
parse("x x 2 - * 1 *").diff("x").simplify().toString()
```
должно возвращать `«x x 2 - +»`
    
4.  Дополнительно реализовать поддержку функций от двух аргументов:

    -   `Hypot` (`hypot`) – квадрат гипотенузы, `3 4 hypot` равно 25;
    -   `HMean` (`hmean`) – гармоническое среднее, `5 20 hmean` равно 8;

5.  При выполнение задания следует обратить внимание на:

    -   Применение инкапсуляции.
    -   Выделение общего кода для операций.
    -   Минимизацию необходимой памяти.

## Домашнее задание 5. Функциональные выражения на JavaScript

[Решение](./src/JSfunctionalExpression/functionalExpression.js)  
[Исходный код тестов](./tests/src/javascript/jstest/functional/FunctionalOneFPTest.java)   

1.  Разработайте функции `cnst`, `variable`, `add`, `subtract`, `multiply`, `divide`, `negate` для вычисления выражений с одной переменной.

2.  Функции должны позволять производить вычисления вида:

    ```
    let expr = subtract(
        multiply(
            cnst(2),
            variable("x")
        ),
        cnst(3)
    );
    
    println(expr(5));
                
    ```

    При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра функции `expr` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.

3.  Тестовая программа должна вычислять выражение `x2−2x+1`, для `x` от 0 до 10.

4.  Требуется дополнительно написать функцию `parse`, осуществляющую разбор выражений, записанных в обратной польской записи. Например, результатом `parse("x x 2 - * x * 1 +")(5)` должно быть число `76`.

5.  Дополнительно реализовать поддержку:

    -   переменных: `y`, `z`
    -   констант:
        -   `one` – 1;
        -   `two` – 2;
    -   операций:
        -   `*+` (`madd`) – тернарный оператор произведение-сумма, `2 3 4 *+` равно 10;
        -   `_` (`floor`) – округление вниз `2.7 _` равно 2;
        -   `^` (`ceil`) – округление вверх `2.7 ^` равно 3.

6.  При выполнение задания следует обратить внимание на:

    -   Применение функций высшего порядка.

    -   Выделение общего кода для операций.
    
### Как запускать тесты

-   Для запуска тестов используется [GraalJS](https://github.com/graalvm/graaljs) (часть проекта [GraalVM](https://www.graalvm.org/), вам не требуется их скачивать отдельно)

-   Для запуска тестов можно использовать скрипты `TestJS.cmd` и `TestJS.sh`

    -   Репозиторий должен быть скачан целиком.
    -   Скрипты должны находиться в каталоге `javascript` (их нельзя перемещать, но можно вызывать из других каталогов).
    -   В качестве аргументов командной строки указывается полное имя класса теста и модификация, например `jstest.functional.FunctionalExpressionTest hard`.

-   Для самостоятельно запуска из консоли необходимо использовать командную строку вида:

    ```
    java -ea --module-path=<js>/graal --class-path <js> jstest.functional.FunctionalExpressionTest {hard|easy}
    ```

    -   `-ea` – включение проверок времени исполнения;
    -   `--module-path=<js>/graal` путь к модулям Graal (здесь и далее `<js>` путь к каталогу `javascript` этого репозитория);
    -   `--class-path <js>` путь к откомпилированным тестам;
    -   {`hard`|`easy`} указание тестируемой модификации.

-   При запуске из IDE, обычно не требуется указывать `--class-path`, так как он формируется автоматически. Остальные опции все равно необходимо указать.

    #### Troubleshooting

    -   `Error occurred during initialization of boot layer java.lang.module.FindException: Module org.graalvm.truffle not found, required by jdk.internal.vm.compiler` – неверно указан `--module-path`;
    -   `Graal.js not found` – неверно указаны `--module-path`
    -   `Error: Could not find or load main class jstest.functional.FunctionalExpressionTest` – неверно указан `--class-path`;
    -   `Error: Could not find or load main class <other class>` – неверно указано полное имя класса теста;
    -   `Exception in thread "main" java.lang.AssertionError: You should enable assertions by running 'java -ea jstest.functional.FunctionalExpressionTest'` – не указана опция `-ea`;
    -   `First argument should be one of: "easy", "hard", found: XXX` – неверно указана сложность;
    -   `Exception in thread "main" jstest.EngineException: Script 'functionalExpression.js' not found` – в текущем каталоге отсутствует решение (`functionalExpression.js`)

## Домашнее задание 4. Вычисление в различных типах

[Решение](./src/expression/generic/GenericTabulator.java)  
[Исходный код тестов](./tests/src/expression/generic/GenericAsmUpbTest.java)   

Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.

1.  Создайте класс `expression.generic.GenericTabulator`, реализующий интерфейс `expression.generic.Tabulator`:

    ```java
       public interface Tabulator {
           Object[][][] tabulate(String mode, String expression, int x1, int x2, int y1, int y2, int z1, int z2) throws Exception;
       }
                
    ```

    -   Дополнительно реализовать унарные операции:
        -   `abs` – модуль числа, `abs -5` равно 5;
        -   `square` – возведение в квадрат, `square 5` равно 25.
    -   Дополнительно реализовать бинарную операцию (максимальный приоритет):
        -   `mod` – взятие по модулю, приоритет как у умножения (`1 + 5 mod 3` равно `1 + (5 mod 3)` равно `3`).

    Аргументы

    -   `mode`— режим работы

        | Режим | Тип                                                       |
        | ----- | --------------------------------------------------------- |
        | `i`   | `int` (с детекцией переполнений)                          |
        | `d`   | `double`                                                  |
        | `bi`  | `BigInteger`                                              |
        | `u`   | вычисления в `int` без проверки на переполнение           |
        | `p`   | вычисления в целых числах в кольце вычетов по модулю 1009 |
        | `b`   | вычисления в `byte` без проверки на переполнение          |

    -   `expression` — вычисляемое выражение;

    -   `x1`, `x2`; `y1`, `y2`; `z1`, `z2` — диапазоны изменения переменны (включительно).

    Возвращаемое значение — таблица значений функции, где `R[i][j][k]` соответствует `x = x1 + i`, `y = y1 + j`, `z = z1 + k`. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть `null`.

2.  Доработайте интерфейс командной строки:

    -   Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:

        | Опция | Тип                              |
        | ----- | -------------------------------- |
        | `-i`  | `int` (с детекцией переполнений) |
        | `-d`  | `double`                         |
        | `-bi` | `BigInteger`                     |
        | `-u`   | вычисления в `int` без проверки на переполнение  |
        | `-p`   | вычисления в целых числах в кольце вычетов по модулю 1009 |
        | `-b`   | вычисления в `byte` без проверки на переполнение |

    -   Вторым аргументом командной строки программа должна принимать выражение для вычисления.

    -   Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.

3.  Реализация не должна содержать [непроверяемых преобразований типов](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.9).

4.  Реализация не должна использовать аннотацию `@SuppressWarnings`.

5.  При выполнении задания следует обратить внимание на простоту добавления новых типов и операциий.

## Домашнее задание 3. Очереди

[Решение](./src/queue/)  
[Исходный код тестов](./tests/src/queue/QueueNthTest.java)  
[Откомпилированные тесты](./tests/compiled/QueueNthTest.jar)  

1.  Определите интерфейс очереди `Queue` и опишите его контракт.
2.  Реализуйте класс `LinkedQueue` — очередь на связном списке.
3.  Выделите общие части классов `LinkedQueue` и `ArrayQueue` в базовый класс `AbstractQueue`.

Это домашнее задание *связанно* с предыдущим.

-   Добавить в интерфейс очереди и реализовать методы
    -   `getNth(n)` – создать очередь, содержащую каждый n-й элемент, считая с 1
    -   `removeNth(n)` – создать очередь, содержащую каждый n-й элемент, и удалить их из исходной очереди
    -   `dropNth(n)` – удалить каждый n-й элемент из исходной очереди
-   Тип возвращаемой очереди должен соответствовать типу исходной очереди
-   Дублирования кода быть не должно

## Домашнее задание 2. Очередь на массиве

[Решение](./src/queue/)  
[Исходный код тестов](./tests/src/queue/ArrayDequeToStrArrayTest.java)  
[Откомпилированные тесты](./tests/compiled/ArrayDequeToStrArrayTest.jar)  

1.  Определите модель и найдите инвариант структуры данных «[очередь](http://ru.wikipedia.org/wiki/Очередь_(программирование))». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия, при условии что очередь не содержит `null`.

2.  Реализуйте классы, представляющие циклическую очередь с применением массива.

    -   Класс `ArrayQueueModule` должен реализовывать один экземпляр очереди с использованием переменных класса.
    -   Класс `ArrayQueueADT` должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
    -   Класс `ArrayQueue` должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
    -   Должны быть реализованы следующие функции (процедуры) / методы:
        -   `enqueue` – добавить элемент в очередь;
        -   `push` – добавить элемент в начало очереди
        -   `element` – первый элемент в очереди;
        -   `peek` – вернуть последний элемент в очереди
        -   `dequeue` – удалить и вернуть первый элемент в очереди;
        -   `remove` – вернуть и удалить последний элемент из очереди
        -   `size` – текущий размер очереди;
        -   Реализовать метод `toArray`, возвращающий массив, содержащий элементы, лежащие в очереди в порядке от головы к хвосту.
        -   Реализовать метод `toStr`, возвращающий строковое представление очереди в виде ‘`[`’ *голова* ‘`,`’ … ‘`,`’ *хвост* ‘`]`‘
        -   `isEmpty` – является ли очередь пустой;
        -   `clear` – удалить все элементы из очереди.
    -   Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
    -   Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.

3.  Напишите тесты к реализованным классам.

## Домашнее задание 1. Бинарный поиск

[Решение](./src/search/BinarySearchMax.java)  
[Исходный код тестов](./tests/src/search/BinarySearchMaxTest.java)  
[Откомпилированные тесты](./tests/compiled/BinarySearchMaxTest.jar)  

1.  Реализуйте итеративный и рекурсивный варианты бинарного поиска максимума в массиве.

2.  На вход подается массив полученный приписыванием отсортированного (строго) по убыванию массива в конец массива отсортированного (строго) по возрастанию. Требуется найти в нем максимальное значение.

3.  Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.

5.  Интерфейс программы.

    -   Имя основного класса — `BinarySearchMax`.
	-   Аргументы командной строки — элементы массива
