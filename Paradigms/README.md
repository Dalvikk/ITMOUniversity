1. [Домашнее задание 8. Линейная алгебра на Clojure](#домашнее-задание-8-линейная-алгебра-на-clojure)  
	1. [Как запускать тесты](#как-запускать-тесты)  
2. [Домашнее задание 7. Обработка ошибок на JavaScript](#домашнее-задание-7-обработка-ошибок-на-javascript)  
3. [Домашнее задание 6. Объектные выражения на JavaScript](#домашнее-задание-6-объектные-выражения-на-javascript)  
4. [Домашнее задание 5. Функциональные выражения на JavaScript](#домашнее-задание-5-функциональные-выражения-на-javascript)  
	1. [Как запускать тесты](#как-запускать-тесты-1)  
5. [Домашнее задание 4. Вычисление в различных типах](#домашнее-задание-4-вычисление-в-различных-типах)  
6. [Домашнее задание 3. Очереди](#домашнее-задание-3-очереди)  
7. [Домашнее задание 2. Очередь на массиве](#домашнее-задание-2-очередь-на-массиве)  
8. [Домашнее задание 1. Бинарный поиск](#домашнее-задание-1-бинарный-поиск)  


# Парадигмы программирования

Домашние работы курса 2-ого семестра «Парадигмы программирования» кафедры КТ, университета ИТМО

## Домашнее задание 8. Линейная алгебра на Clojure

[Решение](./src/clojure-solutions/linear.clj)  
[Исходный код тестов](./tests/src/clojure/cljtest/linear/LinearBroadcastTest.java)  

1.  Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
    -   скаляры – числа
    -   векторы – векторы чисел;
    -   матрицы – векторы векторов чисел.
2.  Функции над векторами:
    -   `v+`/`v-`/`v*`/`vd` – покоординатное сложение/вычитание/умножение/деление;
    -   `scalar`/`vect` – скалярное/векторное произведение;
    -   `v*s` – умножение на скаляр.
3.  Функции над матрицами:
    -   `m+`/`m-`/`m*`/`md` – поэлементное сложение/вычитание/умножение/деление;
    -   `m*s` – умножение на скаляр;
    -   `m*v` – умножение на вектор;
    -   `m*m` – матричное умножение;
    -   `transpose` – транспонирование;
4.  Сложный вариант.
    1.  Ко всем функциям должны быть указаны контракты. Например, нельзя складывать вектора разной длины.
    2.  Все функции должны поддерживать произвольное число аргументов. Например `(v+ [1 2] [3 4] [5 6])` должно быть равно `[9 12]`.
5.  При выполнение задания следует обратить внимание на:
    -   Применение функций высшего порядка.
    -   Выделение общего кода для операций.
6.  Назовем *тензором* многомерную прямоугольную таблицу чисел.
    1.  *Форма* тензора – последовательность чисел   `(s1..n)`=`(s1, s2, …,sn)`, где `n` – размерность тензора, а `si` – число элементов по `i`-ой оси. Например, форма тензора `[[[2 3 4] [5 6 7]]]` равна `(1, 2, 3)`, а форма `1` равна `()`.
    
    2.  Тензор формы `(s1..n)` может быть распространен (`broadcast`) до тензора формы `(u1..m)`, если `(si..n)` является префиксом `(u1..m)`. Для этого, элементы тензора копируются по недостающим осям. Например, распространив тензор `[[1 2]]` формы `(1, 2)` до формы`(1, 2, 3)` получим `[[[1 1 1] [2 2 2]]]`, а распространив `1` до формы `(2, 3)` получим `[[1 1 1] [1 1 1]]`.
    
    3.  Например, тензоры формы `(1, 2, 3)` и `(1, 2)` совместимы, а `(1, 2, 3)` и `(2, 1)` – нет. Числа совместимы с тензорами любой формы.
    
    4.  Добавьте операции поэлементного сложения (`tb+`), вычитания (`tb-`), умножения (`tb*`) и деления (`tbd`) совместимых тензоров. Если формы тензоров не совпадают, то тензоры меньшей размерности должны быть предварительно распространены до тензоров большей размерности. Например, `(tb+ 1 [[10 20 30] [40 50 60]] [100 200])` должно быть равно `[[111 121 131] [241 251 261]]`.

### Как запускать тесты

Для запуска тестов можно использовать скрипты [TestClojure.cmd](./tests/src/clojure/TestClojure.cmd) и [TestClojure.sh](./tests/src/clojure/TestClojure.sh)
	-   Репозиторий должен быть скачан целиком.
	-   Скрипты должны находиться в каталоге `clojure` (их нельзя перемещать, но можно вызывать из других каталогов).
	-   Полное имя класса теста указывается в качестве аргумента командной строки, например, `cljtest.linear.LinearTest`.
	-   Тестируемое решение должно находиться в текущем каталоге.

## Домашнее задание 7. Обработка ошибок на JavaScript

[Решение](./src/javascript-solutions/objectExpression_hw7.js)  
[Исходный код тестов](./tests/src/javascript/jstest/prefix/PostfixMeansTest.java)

1.  Добавьте в предыдущее домашнее задание функцию `parsePrefix(string)`, разбирающую выражения, задаваемые записью вида `(- (* 2 x) 3)`. Если разбираемое выражение некорректно, метод `parsePrefix` должен бросать человеко-читаемое сообщение об ошибке.
2.  Добавьте в предыдущее домашнее задание метод `prefix()`, выдающий выражение в формате, ожидаемом функцией `parsePrefix`.
3.  При выполнение задания следует обратить внимание на:
    -   Применение инкапсуляции.
    -   Выделение общего кода для операций.
    -   Минимизацию необходимой памяти.
    -   Обработку ошибок.

Дополнительно реализовать поддержку:

*   операций произвольного числа аргументов:
*   `ArithMean` (`arith-mean`) – арифметическое среднее `(arith-mean 1 2 6)` равно 3;
*   `GeomMean` (`geom-mean`) – геометрическое среднее `(geom-mean 1 2 4)` равно 2;
*   `HarmMean` (`harm-mean`) – гармоническое среднее, `(harm-mean 2 3 6)` равно 3;

## Домашнее задание 6. Объектные выражения на JavaScript

[Решение](./src/javascript-solutions/objectExpression.js)  
[Исходный код тестов](./tests/src/javascript/jstest/object/ObjectHarmonicTest.java)

1.  Разработайте классы`Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate`, для представления выражений с одной переменной.

  1.  Пример описания выражения `2x-3`
```javascript
let expr = new Subtract(
            new Multiply(
            new Const(2),
                new Variable("x")
        ),
            new Const(3)
);
    console.log(expr.evaluate(5));      
```
  2.  При вычислении такого выражения вместо каждой переменной подставляется её значение, переданное в качестве аргумента метода `evaluate`. Таким образом, результатом вычисления приведенного примера должно стать число 7.
  3.  Метод `toString()` должен выдавать запись выражения в [обратной польской записи](https://ru.wikipedia.org/wiki/Обратная_польская_запись). Например, `expr.toString()` должен выдавать «`2 x * 3 -`».

2.  Сложный вариант.

    Метод `diff("x")` должен возвращать выражение, представляющее производную исходного выражения по переменной `x`. Например, `expr.diff("x")` должен возвращать выражение, эквивалентное `new Const(2)` (выражения `new Subtract(new Const(2), new Const(0))` и

    ```javascript
    new Subtract(
        new Add(
            new Multiply(new Const(0), new Variable("x")),
            new Multiply(new Const(2), new Const(1))
        )
        new Const(0)
    )            
    ```

так же будут считаться правильным ответом).

Функция `parse` должна выдавать разобранное объектное выражение.   

3.  Бонусный вариант.

    Требуется написать метод `simplify()`, производящий вычисления константных выражений. Например,

```javascript
parse("x x 2 - * 1 *").diff("x").simplify().toString()
```
должно возвращать `«x x 2 - +»`

4.  Дополнительно реализовать поддержку функций от двух аргументов:

    -   `Hypot` (`hypot`) – квадрат гипотенузы, `3 4 hypot` равно 25;
    -   `HMean` (`hmean`) – гармоническое среднее, `5 20 hmean` равно 8;

5.  При выполнение задания следует обратить внимание на:

    -   Применение инкапсуляции.
    -   Выделение общего кода для операций.
    -   Минимизацию необходимой памяти.

## Домашнее задание 5. Функциональные выражения на JavaScript

[Решение](./src/javascript-solutions/functionalExpression.js)  
[Исходный код тестов](./tests/src/javascript/jstest/functional/FunctionalOneFPTest.java)   

1.  Разработайте функции `cnst`, `variable`, `add`, `subtract`, `multiply`, `divide`, `negate` для вычисления выражений с одной переменной.

2.  Функции должны позволять производить вычисления вида:

    ```
    let expr = subtract(
        multiply(
            cnst(2),
            variable("x")
        ),
        cnst(3)
    );

    println(expr(5));

    ```

    При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра функции `expr` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.

3.  Тестовая программа должна вычислять выражение `x2−2x+1`, для `x` от 0 до 10.

4.  Требуется дополнительно написать функцию `parse`, осуществляющую разбор выражений, записанных в обратной польской записи. Например, результатом `parse("x x 2 - * x * 1 +")(5)` должно быть число `76`.

5.  Дополнительно реализовать поддержку:

    -   переменных: `y`, `z`
    -   констант:
        -   `one` – 1;
        -   `two` – 2;
    -   операций:
        -   `*+` (`madd`) – тернарный оператор произведение-сумма, `2 3 4 *+` равно 10;
        -   `_` (`floor`) – округление вниз `2.7 _` равно 2;
        -   `^` (`ceil`) – округление вверх `2.7 ^` равно 3.

6.  При выполнение задания следует обратить внимание на:

    -   Применение функций высшего порядка.

    -   Выделение общего кода для операций.

### Как запускать тесты

-   Для запуска тестов используется [GraalJS](https://github.com/graalvm/graaljs) (часть проекта [GraalVM](https://www.graalvm.org/), вам не требуется их скачивать отдельно)

-   Для запуска тестов можно использовать скрипты `TestJS.cmd` и `TestJS.sh`

    -   Репозиторий должен быть скачан целиком.
    -   Скрипты должны находиться в каталоге `javascript` (их нельзя перемещать, но можно вызывать из других каталогов).
    -   В качестве аргументов командной строки указывается полное имя класса теста и модификация, например `jstest.functional.FunctionalExpressionTest hard`.

-   Для самостоятельно запуска из консоли необходимо использовать командную строку вида:

    ```
    java -ea --module-path=<js>/graal --class-path <js> jstest.functional.FunctionalExpressionTest {hard|easy}
    ```

    -   `-ea` – включение проверок времени исполнения;
    -   `--module-path=<js>/graal` путь к модулям Graal (здесь и далее `<js>` путь к каталогу `javascript` этого репозитория);
    -   `--class-path <js>` путь к откомпилированным тестам;
    -   {`hard`|`easy`} указание тестируемой модификации.

-   При запуске из IDE, обычно не требуется указывать `--class-path`, так как он формируется автоматически. Остальные опции все равно необходимо указать.

    #### Troubleshooting

    -   `Error occurred during initialization of boot layer java.lang.module.FindException: Module org.graalvm.truffle not found, required by jdk.internal.vm.compiler` – неверно указан `--module-path`;
    -   `Graal.js not found` – неверно указаны `--module-path`
    -   `Error: Could not find or load main class jstest.functional.FunctionalExpressionTest` – неверно указан `--class-path`;
    -   `Error: Could not find or load main class <other class>` – неверно указано полное имя класса теста;
    -   `Exception in thread "main" java.lang.AssertionError: You should enable assertions by running 'java -ea jstest.functional.FunctionalExpressionTest'` – не указана опция `-ea`;
    -   `First argument should be one of: "easy", "hard", found: XXX` – неверно указана сложность;
    -   `Exception in thread "main" jstest.EngineException: Script 'functionalExpression.js' not found` – в текущем каталоге отсутствует решение (`functionalExpression.js`)

## Домашнее задание 4. Вычисление в различных типах

[Решение](./src/java-solutions/expression/generic/GenericTabulator.java)  
[Исходный код тестов](./tests/src/expression/generic/GenericAsmUpbTest.java)   

Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.

1.  Создайте класс `expression.generic.GenericTabulator`, реализующий интерфейс `expression.generic.Tabulator`:

    ```java
       public interface Tabulator {
           Object[][][] tabulate(String mode, String expression, int x1, int x2, int y1, int y2, int z1, int z2) throws Exception;
       }

    ```

    -   Дополнительно реализовать унарные операции:
        -   `abs` – модуль числа, `abs -5` равно 5;
        -   `square` – возведение в квадрат, `square 5` равно 25.
    -   Дополнительно реализовать бинарную операцию (максимальный приоритет):
        -   `mod` – взятие по модулю, приоритет как у умножения (`1 + 5 mod 3` равно `1 + (5 mod 3)` равно `3`).

    Аргументы

    -   `mode`— режим работы

        | Режим | Тип                                                       |
        | ----- | --------------------------------------------------------- |
        | `i`   | `int` (с детекцией переполнений)                          |
        | `d`   | `double`                                                  |
        | `bi`  | `BigInteger`                                              |
        | `u`   | вычисления в `int` без проверки на переполнение           |
        | `p`   | вычисления в целых числах в кольце вычетов по модулю 1009 |
        | `b`   | вычисления в `byte` без проверки на переполнение          |

    -   `expression` — вычисляемое выражение;

    -   `x1`, `x2`; `y1`, `y2`; `z1`, `z2` — диапазоны изменения переменны (включительно).

    Возвращаемое значение — таблица значений функции, где `R[i][j][k]` соответствует `x = x1 + i`, `y = y1 + j`, `z = z1 + k`. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть `null`.

2.  Доработайте интерфейс командной строки:

    -   Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:

        | Опция | Тип                              |
        | ----- | -------------------------------- |
        | `-i`  | `int` (с детекцией переполнений) |
        | `-d`  | `double`                         |
        | `-bi` | `BigInteger`                     |
        | `-u`   | вычисления в `int` без проверки на переполнение  |
        | `-p`   | вычисления в целых числах в кольце вычетов по модулю 1009 |
        | `-b`   | вычисления в `byte` без проверки на переполнение |

    -   Вторым аргументом командной строки программа должна принимать выражение для вычисления.

    -   Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.

3.  Реализация не должна содержать [непроверяемых преобразований типов](https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.9).

4.  Реализация не должна использовать аннотацию `@SuppressWarnings`.

5.  При выполнении задания следует обратить внимание на простоту добавления новых типов и операциий.

## Домашнее задание 3. Очереди

[Решение](./src/java-solutions/queue/)  
[Исходный код тестов](./tests/src/queue/QueueNthTest.java)  
[Откомпилированные тесты](./tests/compiled/QueueNthTest.jar)  

1.  Определите интерфейс очереди `Queue` и опишите его контракт.
2.  Реализуйте класс `LinkedQueue` — очередь на связном списке.
3.  Выделите общие части классов `LinkedQueue` и `ArrayQueue` в базовый класс `AbstractQueue`.

Это домашнее задание *связанно* с предыдущим.

-   Добавить в интерфейс очереди и реализовать методы
    -   `getNth(n)` – создать очередь, содержащую каждый n-й элемент, считая с 1
    -   `removeNth(n)` – создать очередь, содержащую каждый n-й элемент, и удалить их из исходной очереди
    -   `dropNth(n)` – удалить каждый n-й элемент из исходной очереди
-   Тип возвращаемой очереди должен соответствовать типу исходной очереди
-   Дублирования кода быть не должно

## Домашнее задание 2. Очередь на массиве

[Решение](./src/java-solutions/queue/)  
[Исходный код тестов](./tests/src/queue/ArrayDequeToStrArrayTest.java)  
[Откомпилированные тесты](./tests/compiled/ArrayDequeToStrArrayTest.jar)  

1.  Определите модель и найдите инвариант структуры данных «[очередь](http://ru.wikipedia.org/wiki/Очередь_(программирование))». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия, при условии что очередь не содержит `null`.

2.  Реализуйте классы, представляющие циклическую очередь с применением массива.

    -   Класс `ArrayQueueModule` должен реализовывать один экземпляр очереди с использованием переменных класса.
    -   Класс `ArrayQueueADT` должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
    -   Класс `ArrayQueue` должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
    -   Должны быть реализованы следующие функции (процедуры) / методы:
        -   `enqueue` – добавить элемент в очередь;
        -   `push` – добавить элемент в начало очереди
        -   `element` – первый элемент в очереди;
        -   `peek` – вернуть последний элемент в очереди
        -   `dequeue` – удалить и вернуть первый элемент в очереди;
        -   `remove` – вернуть и удалить последний элемент из очереди
        -   `size` – текущий размер очереди;
        -   Реализовать метод `toArray`, возвращающий массив, содержащий элементы, лежащие в очереди в порядке от головы к хвосту.
        -   Реализовать метод `toStr`, возвращающий строковое представление очереди в виде ‘`[`’ *голова* ‘`,`’ … ‘`,`’ *хвост* ‘`]`‘
        -   `isEmpty` – является ли очередь пустой;
        -   `clear` – удалить все элементы из очереди.
    -   Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
    -   Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.

3.  Напишите тесты к реализованным классам.

## Домашнее задание 1. Бинарный поиск

[Решение](./src/java-solutions/search/BinarySearchMax.java)  
[Исходный код тестов](./tests/src/search/BinarySearchMaxTest.java)  
[Откомпилированные тесты](./tests/compiled/BinarySearchMaxTest.jar)  

1.  Реализуйте итеративный и рекурсивный варианты бинарного поиска максимума в массиве.

2.  На вход подается массив полученный приписыванием отсортированного (строго) по убыванию массива в конец массива отсортированного (строго) по возрастанию. Требуется найти в нем максимальное значение.

3.  Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.

5.  Интерфейс программы.

    -   Имя основного класса — `BinarySearchMax`.
	-   Аргументы командной строки — элементы массива